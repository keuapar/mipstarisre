<!DOCTYPE html>

<html>
    <head>
      <title>MIP* = RE</title>
      <meta charset="utf-8" />
      <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
      <link rel="stylesheet" href="assets/css/main.css" />
      <link rel="stylesheet" href="assets/css/jquery-ui.min.css" />
      <link rel="stylesheet" href="assets/css/jquery-ui.structure.min.css" />

      <!--- KaTeX for rendering math equations -->
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.css" integrity="sha384-zTROYFVGOfTw7JV7KUu8udsvW2fx4lWOsCEDqhBreBwlHI4ioVRtmIvEThzJHGET" crossorigin="anonymous">
      <!-- The loading of KaTeX is deferred to speed up page rendering -->
      <script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.js" integrity="sha384-GxNFqL3r9uRJQhR+47eDxuPoNE7yLftQM8LcxzgS4HT73tp970WS/wV5p8UzCOmb" crossorigin="anonymous"></script>
      <!-- To automatically render math in text elements, include the auto-render extension: -->
      <script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/contrib/auto-render.min.js" integrity="sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl" crossorigin="anonymous"
          onload="renderMathInElement(document.body);"></script>
    </head>

    <body>
        <!-- Navigation hiearchy -->
        <nav>
            <div class="nav_list">
                <a href="#home">Home</a>
                <a href="#classP">Class P: Sorting</a>
                <a href="#decisionproblems">- Decision problems</a>
                <a href="#classBPP">Class BPP: Polynomial Identity Testing</a>
                <a href="#proversverifiers">- Solvers and verifiers</a>
                <a href="#classIP">Class IP: Graph Non-Isomorphism</a>
                <a href="#nonlocalgames">- Nonlocal games</a>
                <a href="#classMIP">Class MIP: The CHSH game</a>
                <a href="#quantumentanglement">- Quantum Entanglement</a>
                <a href="#classMIPstar">Class MIP*: The CHSH game</a>
                <a href="#mipstarisre">- MIP* = RE</a>
            </div>
            <div class="nav_btns">
                <a title="Scroll to Top" href="#home" class="fas fa-angle-double-up" id="Bupup"></a>
                <a title="Previous Section" href="#" class="fas fa-angle-up" id="Bup"></a>
                <a title="Show Navigation" href="javascript:void(0);" class="fas fa-angle-double-right" id="Bnav"></a>
                <a title="Next Section" href="#" class="fas fa-angle-down" id="Bdown"></a>
                <a title="Scroll to Conclusion" href="#" class="fas fa-angle-double-down" id="Bdowndown"></a>
            </div>
        </nav>

        <div class="main main_WIDE">

            <!-- SECTION 00 -->
            <!-- INTRODUCTION -->
            <section id="home">
                <h2 class="intro">Welcome to</h2>
                <h1 class="intro">Understanding of MIP* = RE</h1>
                <canvas id="introCanvas"><p>Graphics of circles</p></canvas>
                <h5 class="i1">Class P</h5>
                <h5 class="i2">Class BPP</h5>
                <h5 class="i3">Class IP</h5>
                <h5 class="i4">Class MIP</h5>
                <h5 class="i5">Class MIP*</h5>
            </section>

            <!-- SECTION 01 -->
            <!-- SORTING -->
            <section class="grid" id="classP">
                <div class="head">
                    <h2>Class P: Sorting</h2>
                </div>
                <div class="main-intro">
                    <p>
                        One of the more straightforward ways to understand the notion of computational complexity is via the traditional exercises on sorting.
                    </p>
                    <p>
                        How long does it take you to sort the library below from shortest to tallest book?
                    </p>
                </div>
                <div class="main-act s01_main">
                    <div class="s01_wrap" id="s01_wrap">
                        <!-- dynamically populated -->
                    </div>
                    <div class="s01_shelf"></div>
                </div>
                <div class="main-butt">
                    <div class="button b-green s01_reset">
                        <h3>TRY AGAIN</h3>
                    </div>
                    <div class="s01_timer timer">
                        <!-- dynamically populated -->
                    </div>
                    <div class="button b-orange s01_harder">
                        <h3>MORE BOOKS</h3>
                    </div>
                </div>
                <div class="plot">
                    <div class="plot_wrap s01_plot" id="s01_plot">
                        <!-- dynamically populated -->
                    </div>
                </div>
                <div class="plot-butt">
                    <div class="button b-blue b-explain-01" data-plot="s01_plt">
                        <h3 class="b-explain">EXPLAIN</h3>
                    </div>
                    <div class="button b-purple b-links">
                        <h3 class="b-link">LINKS</h3>
                    </div>
                </div>
                <div class="overlay hide overlay_explains">
                    <p>
                        Let's formalize the library problem. There is a number of books, \(N\), which we need to reorder to produce a sorted list.
                        If we are interested in the efficiency of the algorithm, we look at its asymptotic runtime [link].
                        The runtime is described by big-O notation [link], which describes the worst-case behaviour of the alrgorithm.
                    </p>
                    <p>
                        In most cases, the speed of the algorithm depends on how large \(N\) is, and we are most interested in how much
                        the algorithm slows down as \(N\) increases. For example, if the algorithm always takes \(N\) steps to finish
                        (it might be just checking if the list is sorter, for example [link]), we say it runs in linear time, \(O(N)\).
                    </p>
                    <p>
                        However, when sorting a list, algorithms need to go back and forth, reordering elements, which cannot be done in one fell swoop.
                        So, many algorithms take multiple times the length of the list to sort it. Some of the most common algorithms for sorting 
                        can take \(O(N\log N)\) [link] or even \(O(N^2)\) [link] time. In the last case, as the list doubles in size, the time takes to sort it quadruples. 
                    </p>
                    <p>
                        You can see how these two algorithms fare on the plot on the right. As they both take at most polynomial time in the size of the input
                        to finish sorting, we say that they belong to the \(P\) class of problems, our first complexity class.
                    </p>
                </div>
                <div class="overlay hide overlay_links">
                    <h3>Encyclopedia links</h3>
                    <div class="links">
                        <a class="link" href="https://www.wikiwand.com/en/Complexity_class" target="_blank">
                            <canvas></canvas>
                            <p>Complexity Classes</p>
                            <p class="link_src">Wikipedia</p>
                        </a>
                        <a class="link" href="https://www.wikiwand.com/en/FP_(complexity)" target="_blank">
                            <canvas></canvas>
                            <p>Complexity of Function Problems</p>
                            <p class="link_src">Wikipedia</p>
                        </a>
                        <a class="link" href="https://www.wikiwand.com/en/P_(complexity)" target="_blank">
                            <canvas></canvas>
                            <p>Complexity Class P</p>
                            <p class="link_src">Wikipedia</p>
                        </a>
                        <a class="link" href="https://www.wikiwand.com/en/Computational_problem" target="_blank">
                            <canvas></canvas>
                            <p>Types of computational problems</p>
                            <p class="link_src">Wikipedia</p>
                        </a>
                        <a class="link" href="https://complexityzoo.net/Complexity_Zoo:F#fp" target="_blank">
                            <canvas></canvas>
                            <p>Class FP: Function Polynomial-Time</p>
                            <p class="link_src">Complexity Zoo</p>
                        </a>
                        <a class="link" href="https://complexityzoo.net/Complexity_Zoo:P#p" target="_blank">
                            <canvas></canvas>
                            <p>Class P: Polynomial-Time</p>
                            <p class="link_src">Complexity Zoo</p>
                        </a>
                    </div>
                    <h3>Beginner Resources</h3>
                    <div class="links">
                        <a class="link" href="https://cs.stackexchange.com/questions/79707/does-every-computational-problem-have-a-decision-version" target="_blank">
                            <canvas></canvas>
                            <p>Do all problems have decision versions?</p>
                            <p class="link_src">Stack Exchange</p>
                        </a>
                        <a class="link" href="https://cstheory.stackexchange.com/questions/37812/what-exactly-are-the-classes-fp-fnp-and-tfnp" target="_blank">
                            <canvas></canvas>
                            <p>What are the FP, FNP and TFNP classes?</p>
                            <p class="link_src">Stack Exchange</p>
                        </a>
                        <a class="link" href="https://brilliant.org/wiki/turing-machines/?subtopic=algorithms&chapter=computability" target="_blank">
                            <canvas></canvas>
                            <p>What are Turing Machines?</p>
                            <p class="link_src">Brilliant</p>
                        </a>
                        <a class="link" href="https://www.cs.stanford.edu/~trevisan/cs254-10/lecture02.pdf" target="_blank">
                            <canvas></canvas>
                            <p>About Computational Problems</p>
                            <p class="link_src">Luca Trevisan</p>
                        </a>
                        <a class="link" href="http://www.cs.ecu.edu/karl/6420/spr16/Notes/P/examples.html" target="_blank">
                            <canvas></canvas>
                            <p>Examples of problems in P</p>
                            <p class="link_src">East Carolina University</p>
                        </a>
                        <a class="link" href="https://www.youtube.com/watch?v=WaNLJf8xzC4" target="_blank">
                            <canvas></canvas>
                            <p>What's the fastest way to sort your bookshelf?</p>
                            <p class="link_src">TED-Ed</p>
                        </a>
                        <a class="link" href="https://www.geeksforgeeks.org/time-complexities-of-all-sorting-algorithms/" target="_blank">
                            <canvas></canvas>
                            <p>Time complexities of sorting algorithms</p>
                            <p class="link_src">Geeks for Geeks</p>
                        </a>
                    </div>
                    <h3>Advanced Study</h3>
                    <div class="links">
                        <a class="link" href="https://www.sciencedirect.com/science/article/pii/S0022000005800091" target="_blank">
                            <canvas></canvas>
                            <p>A taxonomy of complexity classes of functions</p>
                            <p class="link_src">Alan L. Selman</p>
                        </a>
                        <a class="link" href="https://klein.mit.edu/~sipser/book.html" target="_blank">
                            <canvas></canvas>
                            <p>Introduction to the Theory of Computation (3rd ed.)</p>
                            <p class="link_src">Michael Sipser</p>
                        </a>
                        <a class="link" href="https://www.cs.utexas.edu/~ear/cs341/automatabook/AutomataTheoryBook.pdf" target="_blank">
                            <canvas></canvas>
                            <p>Automata, Computability and Complexity</p>
                            <p class="link_src">Elaine Rich</p>
                        </a>
                    </div>
                </div>       
            </section>

            <!-- SECTION 01.5 -->
            <!-- DECISION PROBLEMS -->
            <section class="grid" id="decisionproblems">
                <div class="head">
                    <h2>Types of computational problems</h2>
                </div>
                <div class="main-full">
                    <p>
                        On the previous page, we dealt with sorting. This is known as a function problem: The input is a list, and the output is the sorted list.
                        Another common type of problem is an optimization problem: Ask what is the best possible output given some input and evaluation criteria.
                        However, for us the focus are decision problems: reframing such that the output is a binary YES or NO.
                    </p>
                    <p>
                        We can often transform function and optimization problems into decision problems, although the complexity introduced on the previous page
                        does not have to be kept in that transformation. For example, a sorting problem might be rephrased as "is this list sorted?".
                        Obviously, this solves a slightly different problem, and is also way easier, just compare each pair of elements in turn and check their order.
                    </p>
                    <p>
                        There is a lot of theory already for all sorts of problems, but decision problems are the most examined.
                        Technically, "class P" on the previous page refers only to the decision problem of "is this list sorted?" and since we can do this in linear time
                        checking if a list is sorted would belong to an even smaller class.
                    </p>
                    <p>
                        Similarly, the rest of this website deals with other decision problems, to which the answers are either YES or NO,
                        and complexity of these problems explores how long it takes to make this decision, in relation to the input size.
                    </p>
                    <p>
                        We can also define space complexity, which constrains the memory the algorithm needs to decide a problem instead of time.
                    </p>
                </div>
                <div class="plot">
                    <h5>FUNCTION PROBLEMS</h5>
                    <p>The goal is to transform an input into an output, for example "Find a factor of X" or "Find all factors of X".</p>
                    <h5>OPTIMIZATION PROBLEMS</h5>
                    <p>The goal is to find the "best" output given an input and constraints, like "Find the shortest path through graph G".</p>
                    <h5>our focus: DECISION PROBLEMS</h5>
                    <p>The goal is to decide a YES/NO question, for example "Are these graphs G1, G2 isomorphisms of each other?" or "Is P prime?"</p>
                </div>
                <div class="plot-butt">
                </div>
                <div class="overlay hide overlay_explains">
                </div>
                <div class="overlay hide overlay_links">
                </div>       
            </section>

            <!-- SECTION 02 -->
            <!-- POLYNOMIAL IDENTITY TESTING -->
            <section class="grid" id="classBPP">
                <div class="head">
                    <h2>Class BPP: Polynomial Identity Testing</h2>
                </div>
                <div class="main-intro">
                    <p>
                        Next up, we introduce another toy problem. Can you tell whether the following two polynomials are equal?
                        How much harder does it get as you increase the highest degree, or number of variables (guessing doesn't count!)?
                    </p>
                </div>
                <div class="main-act s02_main">
                    <span class="s02_eq">$$k^2 - l^2 \stackrel{?}{=} (k+l)(k-l)$$</span>
                    <div class="s02_intro">What steps does the computer take?</div>
                    <div class="s02_anim"></div>
                </div>
                <div class="main-butt">
                    <div class="button b-orange s02_prev">
                        <h3>PREVIOUS</h3>
                    </div>
                    <div class="button b-green s02_true">
                        <h3>TRUE</h3>
                    </div>
                    <div class="button b-red s02_false">
                        <h3>FALSE</h3>
                    </div>
                    <div class="button b-orange s02_next">
                        <h3>NEXT</h3>
                    </div>
                </div>
                <div class="plot">
                    <div class="plot_wrap s02_plot" id="s02_plot">
                        <!-- dynamically populated -->
                    </div>
                </div>
                <div class="plot-butt">
                    <div class="button b-blue b-explain-02">
                        <h3 class="b-explain">EXPLAIN</h3>
                    </div>
                    <div class="button b-purple b-links">
                        <h3 class="b-link">LINKS</h3>
                    </div>
                </div>
                <div class="overlay hide overlay_explains">
                    <p>
                        The algorithmic approach to find out whether two polynomials are equivalent is to expand all terms and then compare their coefficients. 
                        We can find some time savings by removing like terms as soon as they appear, without doing all addition, but that's rather coincidental. 
                        Overall, this brute-force approach is very inefficient, and scales as \({n+d \choose d}\) for number of variables \(n\) and degree \(d\).
                    </p>
                    <p>
                        However, with some leeway we can make solving this problem way more efficient. The first step is to transform it: 
                        Instead of asking whether two polynomials are equal, \(p\stackrel{?}=q\), we ask whether their difference is equal to the zero polynomial, \(p-q\stackrel{?}=0\). 
                        This is the same as asking whether a polynomial \(p'=p-q\) is equal to \(0\).
                    </p>
                    <p>
                        One way to find out is to evaluate it at any point/vector \(x\): \(p'(x)\). If the result is anything but \(0\), we can be very certaint that the polynomial is non-zero.
                        If the result is \(0\), the polynomial could very well be zero. We can try another point to verify... and as we increase the number of points, if all evaluate to zero,
                        we become very confident that the polynomial is indeed equal to the zero polynomial, or that the two polynomials are equal.
                    </p>
                    <p>
                        With some smart choice of points to evaluate at and a surprisingly reasonable number of repetitions (in hundreds), we can achieve very high probability of a YES answer being a true YES.
                        This makes the algorithm highly practical - for example Horner's method for polynomial evaluation runs in \(O(n^2)\), which you can see plotted on the graph.
                    </p> 
                    <p>
                        The algorithm we have defined always returns a NO if the true answer is NO, and almost always returns a YES if the true answer is YES. It can do this in polynomial time.
                        We call this class of problems \(RP\), for Randomized Polynomial time. If the roles of YES and NO were reversed, the class would be \(co-RP\).
                        If we allow either answer to be probabilistic with some constant confidence, the class putting that together is \(BPP\), bounded-error probabilistic polynomial time.
                    </p>
                </div>
                <div class="overlay hide overlay_links">
                    <h3>Encyclopedia links</h3>
                    <div class="links">
                        <a class="link" href="https://www.wikiwand.com/en/Complexity_class" target="_blank">
                            <canvas></canvas>
                            <p>Complexity Classes</p>
                            <p class="link_src">Wikipedia</p>
                        </a>
                        <a class="link" href="https://www.wikiwand.com/en/FP_(complexity)" target="_blank">
                            <canvas></canvas>
                            <p>Complexity of Function Problems</p>
                            <p class="link_src">Wikipedia</p>
                        </a>
                        <a class="link" href="https://www.wikiwand.com/en/P_(complexity)" target="_blank">
                            <canvas></canvas>
                            <p>Complexity Class P</p>
                            <p class="link_src">Wikipedia</p>
                        </a>
                        <a class="link" href="https://www.wikiwand.com/en/Computational_problem" target="_blank">
                            <canvas></canvas>
                            <p>Types of computational problems</p>
                            <p class="link_src">Wikipedia</p>
                        </a>
                        <a class="link" href="https://complexityzoo.net/Complexity_Zoo:F#fp" target="_blank">
                            <canvas></canvas>
                            <p>Class FP: Function Polynomial-Time</p>
                            <p class="link_src">Complexity Zoo</p>
                        </a>
                        <a class="link" href="https://complexityzoo.net/Complexity_Zoo:P#p" target="_blank">
                            <canvas></canvas>
                            <p>Class P: Polynomial-Time</p>
                            <p class="link_src">Complexity Zoo</p>
                        </a>
                    </div>
                    <h3>Beginner Resources</h3>
                    <div class="links">
                        <a class="link" href="https://cs.stackexchange.com/questions/79707/does-every-computational-problem-have-a-decision-version" target="_blank">
                            <canvas></canvas>
                            <p>Do all problems have decision versions?</p>
                            <p class="link_src">Stack Exchange</p>
                        </a>
                        <a class="link" href="https://cstheory.stackexchange.com/questions/37812/what-exactly-are-the-classes-fp-fnp-and-tfnp" target="_blank">
                            <canvas></canvas>
                            <p>What are the FP, FNP and TFNP classes?</p>
                            <p class="link_src">Stack Exchange</p>
                        </a>
                        <a class="link" href="https://brilliant.org/wiki/turing-machines/?subtopic=algorithms&chapter=computability" target="_blank">
                            <canvas></canvas>
                            <p>What are Turing Machines?</p>
                            <p class="link_src">Brilliant</p>
                        </a>
                        <a class="link" href="https://www.cs.stanford.edu/~trevisan/cs254-10/lecture02.pdf" target="_blank">
                            <canvas></canvas>
                            <p>About Computational Problems</p>
                            <p class="link_src">Luca Trevisan</p>
                        </a>
                        <a class="link" href="http://www.cs.ecu.edu/karl/6420/spr16/Notes/P/examples.html" target="_blank">
                            <canvas></canvas>
                            <p>Examples of problems in P</p>
                            <p class="link_src">East Carolina University</p>
                        </a>
                        <a class="link" href="https://www.youtube.com/watch?v=WaNLJf8xzC4" target="_blank">
                            <canvas></canvas>
                            <p>What's the fastest way to sort your bookshelf?</p>
                            <p class="link_src">TED-Ed</p>
                        </a>
                        <a class="link" href="https://www.geeksforgeeks.org/time-complexities-of-all-sorting-algorithms/" target="_blank">
                            <canvas></canvas>
                            <p>Time complexities of sorting algorithms</p>
                            <p class="link_src">Geeks for Geeks</p>
                        </a>
                    </div>
                    <h3>Advanced Study</h3>
                    <div class="links">
                        <a class="link" href="https://www.sciencedirect.com/science/article/pii/S0022000005800091" target="_blank">
                            <canvas></canvas>
                            <p>A taxonomy of complexity classes of functions</p>
                            <p class="link_src">Alan L. Selman</p>
                        </a>
                        <a class="link" href="https://klein.mit.edu/~sipser/book.html" target="_blank">
                            <canvas></canvas>
                            <p>Introduction to the Theory of Computation (3rd ed.)</p>
                            <p class="link_src">Michael Sipser</p>
                        </a>
                        <a class="link" href="https://www.cs.utexas.edu/~ear/cs341/automatabook/AutomataTheoryBook.pdf" target="_blank">
                            <canvas></canvas>
                            <p>Automata, Computability and Complexity</p>
                            <p class="link_src">Elaine Rich</p>
                        </a>
                    </div>
                </div>       
            </section>

            <!-- SECTION 02.5 -->
            <!-- PROVERS AND VERIFIERS -->
            <section class="grid" id="proversverifiers">
                <div class="head">
                    <h2>Solvers and verifiers</h2>
                </div>
                <div class="main-full">
                    <p>
                        Up until now, the machines we were dealing with were solvers. Given an input, they worked through it and showed the process by which to determine the YES/NO answer.
                        Another typical machine used in the theoretical models of decision problems is a verifier.
                        Instead of solving the problem itself, a verifier receives a proof that the problem is solvable, and checks it in some given timeframe.
                    </p>
                    <p>
                        Take for example a partially filled sudoku grid. Is it solvable? To determine the answer, the computer can try all possible fills for each possible cell, and check if all
                        the conditions are satisfied, but this will take a lot of time. For a 9x9 grid, with each cell having 9 options, the runtime will be \(O(9^{9^2})\).
                        However, given a valid fill for the sudoku as proof, a verifier can check that it's valid in linear time. The proof is called a certificate.
                    </p>
                    <p>
                        Another similar situation is in the sorting example - a machine can take a long time to sort a list, but checking that it's sorted is a strictly linear operation - 
                        just check that all neighbouring pairs are in the right order.
                    </p>
                    <p>
                        The question remains how to generate such certificates. Since it's useful to work with them, the theory of computation has an all-powerful machine that can generate
                        such a certificate instantly, called an oracle. The set-up is such that once the verifier receives the problem, it sends it over to the oracle, who responds with a certificate.
                    </p>
                    <p>
                        However, if it responded with no certificate for problems without a solution, it wouldn't be a very useful theoretical construct (the verifier wouldn't have to do any work, just trust the oracle).
                        Instead the oracle is malicious, and always sends a certificate. The verifier must work through it to determine whether it's a valid proof.
                    </p>
                    <p>
                        To solidify the ideas a little, we impose two constraints on our system. If the true answer is YES, the verifier should accept the oracle's proof in a certain percentage of cases (e.g. 95%), 
                        and similarly for NO, the verifier should reject in a given percentage of cases (e.g. 95%). Similarly to the previous problem, we can amend this probability by making this a multi-round game,
                        with the verifier asking more questions.
                    </p>
                </div>
                <div class="plot">
                    <h5>SOLVER</h5>
                    <p>A machine that accepts a problem, determines whether it's answer is YES or NO in its runtime, and returns the answer.</p>
                    <h5>VERIFIER</h5>
                    <p>A machine that accepts a problem and a certificate, and in its runtime verifies whether the certificate provides a true answer to the problem.</p>
                    <h5>ORACLE/PROVER</h5>
                    <p>An all-knowing machine that solves any problem, and returns the YES/NO answer or a certificate for the answer.</p>
                </div>
                <div class="plot-butt">
                </div>
                <div class="overlay hide overlay_explains">
                </div>
                <div class="overlay hide overlay_links">
                </div>       
            </section>

            <!-- SECTION 03 -->
            <!-- GRAPH NON-POLYMORPHISM -->
            <section class="grid" id="classIP">
                <div class="head">
                    <h2>Class IP: Graph Non-Isomorphism</h2>
                </div>
                <div class="main-intro">
                    <p>
                        Let's call our verifier Arthur and our oracle Merlin. You, as Arthur, are trying to determine whether two graphs G1 and G2 are not isomorphic.
                        You know Merlin knows but he'll try to trick you. Your strategy is to secretly toss a coin to choose one of G1 and G2, shuffle the chosen graph around and send it to Merlin.
                        If he can tell which graph it came from, they are (probably) not isomorphic. If he cannot tell, you're certain they are isomorphic!
                    </p>
                </div>
                <div class="main-act s03_main">
                    <div class="s03_g1 s03_graph">
                        <!-- dynamically populated -->
                    </div>
                    <div class="s03_g2 s03_graph">
                        <!-- dynamically populated -->                        
                    </div>
                    <div class="s03_gq s03_graph">
                        <!-- dynamically populated -->
                    </div>
                    <div class="s03_coin">
                        <div id="coin">
                            <div class="coin-g1">
                                <span>G1</span>
                            </div>
                            <div class="coin-g2">
                                <span>G2</span>
                            </div>
                        </div>
                        <i class="fas fa-crown fa-3x"></i>
                    </div>
                    <div class="s03_arthurtext s03_text">
                        <span class="com_text">Hey Merlin, is this a permutation of G1 or G2?</span>
                    </div>
                    <div class="s03_ga s03_graph">
                        <!-- dynamically populated -->
                    </div>
                    <div class="s03_merlin">
                        <i class="fas fa-magic fa-2x"></i>
                        <i class="fas fa-hat-wizard fa-3x"></i> 
                    </div>
                    <div class="s03_merlintext s03_text">
                        <span class="com_text"></span>
                    </div>
                </div>
                <div class="main-butt">
                    <div class="button b-orange s03_flip">
                        <h3>FLIP A COIN</h3>
                    </div>
                    <div class="button b-orange s03_permute">
                        <h3>PERMUTE GRAPH</h3>
                    </div>
                    <div class="button b-orange s03_send">
                        <h3>SEND TO MERLIN</h3>
                    </div>
                    <div class="button b-orange s03_restart">
                        <h3>TRY AGAIN</h3>
                    </div>
                </div>
                <div class="plot">
                    <div class="plot_wrap s03_plot" id="s03_plot">
                        <!-- dynamically populated -->
                    </div>
                </div>
                <div class="plot-butt">
                    <div class="button b-blue b-explains">
                        <h3 class="b-explain-03">EXPLAIN</h3>
                    </div>
                    <div class="button b-purple b-links">
                        <h3 class="b-link">LINKS</h3>
                    </div>
                </div>
                <div class="overlay hide overlay_explains">
                    <p>
                        How long can Merlin keep fooling you? Well, our two graphs are isomorphic. You are welcome to drag their nodes around and check this for yourself.
                        If they are isomorphic, without knowing the result of your cointoss, Merlin can never figure out which graph was used to generate the permutation he received.
                        He can only take a 50/50 guess, and that's why you never believe him straight away. But if he keeps guessing right,
                        you eventually budge and admit that he cannot keep being lucky, and your graphs are indeed non-isomorphic.
                    </p>
                    <p>
                        On ther other hand, as soon as Merlin once tells you the wrong answer, you can be certain that he's trying to fool you!
                        If the graphs were truly non-isomorphic, he must be able to tell which one you started your permutation from.
                    </p>
                    <p>
                        Verifying Merlin's answer takes constant time, but Arthur nonetheless spends time making the permutation in the first place.
                        For the same reason, the complementary problem, deciding whether two graphs ARE isomorphic, is in \(NP\).
                        Given a certificate, a description of the permutation, the verifier can check if its valid in polynomial time.
                    </p>
                    <p>
                        However, our problem of whether graphs AREN'T isomorphic, eludes such simple process, and that's why we have to solve it with Merlin and Arthur.
                        Problems solved with Arthur starting by sending a question to Merlin, and then deciding based on his answer, are in class \(AM[k]\), with \(k\)
                        describing how many "rounds" there have been in their conversation.
                    </p>
                    <p>
                        A more general class of problems, but using the same principle, is called Interactive Proofs, \(IP\).
                    </p>
                </div>
                <div class="overlay hide overlay_links">
                    <h3>Encyclopedia links</h3>
                    <div class="links">
                        <a class="link" href="https://www.wikiwand.com/en/Complexity_class" target="_blank">
                            <canvas></canvas>
                            <p>Complexity Classes</p>
                            <p class="link_src">at Wikipedia</p>
                        </a>
                        <a class="link" href="https://www.wikiwand.com/en/FP_(complexity)" target="_blank">
                            <canvas></canvas>
                            <p>Complexity of Function Problems</p>
                            <p class="link_src">at Wikipedia</p>
                        </a>
                        <a class="link" href="https://www.wikiwand.com/en/P_(complexity)" target="_blank">
                            <canvas></canvas>
                            <p>Complexity Class P</p>
                            <p class="link_src">at Wikipedia</p>
                        </a>
                        <a class="link" href="https://www.wikiwand.com/en/Computational_problem" target="_blank">
                            <canvas></canvas>
                            <p>Types of computational problems</p>
                            <p class="link_src">at Wikipedia</p>
                        </a>
                        <a class="link" href="https://complexityzoo.net/Complexity_Zoo:F#fp" target="_blank">
                            <canvas></canvas>
                            <p>Class FP: Function Polynomial-Time</p>
                            <p class="link_src">at Complexity Zoo</p>
                        </a>
                        <a class="link" href="https://complexityzoo.net/Complexity_Zoo:P#p" target="_blank">
                            <canvas></canvas>
                            <p>Class P: Polynomial-Time</p>
                            <p class="link_src">at Complexity Zoo</p>
                        </a>
                    </div>
                    <h3>Beginner Resources</h3>
                    <div class="links">
                        <a class="link" href="https://cs.stackexchange.com/questions/79707/does-every-computational-problem-have-a-decision-version" target="_blank">
                            <canvas></canvas>
                            <p>Do all problems have decision versions?</p>
                            <p class="link_src">at Stack Exchange</p>
                        </a>
                        <a class="link" href="https://cstheory.stackexchange.com/questions/37812/what-exactly-are-the-classes-fp-fnp-and-tfnp" target="_blank">
                            <canvas></canvas>
                            <p>What are the FP, FNP and TFNP classes?</p>
                            <p class="link_src">at Stack Exchange</p>
                        </a>
                        <a class="link" href="https://brilliant.org/wiki/turing-machines/?subtopic=algorithms&chapter=computability" target="_blank">
                            <canvas></canvas>
                            <p>What are Turing Machines?</p>
                            <p class="link_src">at Brilliant</p>
                        </a>
                        <a class="link" href="https://www.cs.stanford.edu/~trevisan/cs254-10/lecture02.pdf" target="_blank">
                            <canvas></canvas>
                            <p>About Computational Problems</p>
                            <p class="link_src">by Luca Trevisan</p>
                            <p class="link_src">at Stanford University</p>
                        </a>
                        <a class="link" href="http://www.cs.ecu.edu/karl/6420/spr16/Notes/P/examples.html" target="_blank">
                            <canvas></canvas>
                            <p>Examples of problems in P</p>
                            <p class="link_src">at East Carolina University</p>
                        </a>
                        <a class="link" href="https://www.youtube.com/watch?v=WaNLJf8xzC4" target="_blank">
                            <canvas></canvas>
                            <p>What's the fastest way to sort your bookshelf?</p>
                            <p class="link_src">by TED-Ed</p>
                        </a>
                        <a class="link" href="https://www.geeksforgeeks.org/time-complexities-of-all-sorting-algorithms/" target="_blank">
                            <canvas></canvas>
                            <p>Time complexities of sorting algorithms</p>
                            <p class="link_src">by Geeks for Geeks</p>
                        </a>
                    </div>
                    <h3>Advanced Study</h3>
                    <div class="links">
                        <a class="link" href="https://www.sciencedirect.com/science/article/pii/S0022000005800091" target="_blank">
                            <canvas></canvas>
                            <p>A taxonomy of complexity classes of functions</p>
                            <p class="link_src">by Alan L. Selman</p>
                            <p class="link_src">in Journal of Computer and System Sciences</p>
                        </a>
                        <a class="link" href="https://klein.mit.edu/~sipser/book.html" target="_blank">
                            <canvas></canvas>
                            <p>Introduction to the Theory of Computation (3rd ed.)</p>
                            <p class="link_src">by Michael Sipser</p>
                        </a>
                        <a class="link" href="https://www.cs.utexas.edu/~ear/cs341/automatabook/AutomataTheoryBook.pdf" target="_blank">
                            <canvas></canvas>
                            <p>Automata, Computability and Complexity</p>
                            <p class="link_src">by Elaine Rich</p>
                        </a>
                    </div>
                </div>       
            </section>

            <!-- SECTION 03.5 -->
            <!-- NONLOCAL GAMES -->
            <section class="grid" id="nonlocalgames">
                <div class="head">
                    <h2>Nonlocal games</h2>
                </div>
                <div class="main-full">
                    <p>
                        As we move on, we will need to expand the interactive proof idea from our Arthur-Merlin argument. We remain in the verifier seat, but this time question two provers at once.
                        This setup is called a multiprover interactive proof. The provers can setup a common strategy beforehand, but cannot communicate once the protocol starts.
                        The notion is that this allows us to cross check their answers and be more certain in our analysis.
                    </p>
                    <p>
                        We will only have 2 provers and a single round of interaction (1 question to each prover and their answer). This class is called \(MIP(2,1)\), and \(MIP(2,1) = MIP\), so any
                        other setup, with more provers and more rounds, can be smartly reduced to ours. This system can also be reformulated as a so-called Nonlocal game.
                    </p>
                    <p>
                        In this game, our two provers are players, and the verifier is a referee. The referee sends the players each a question, and based on their answers decides whether they win.
                        The players know the full rules of the game and can setup a strategy together beforehand, but cannot communicate once the game starts.
                        However, since the referee's questions are probabilistic (drawn from a known distribution), the players can't be sure that they always win.
                    </p>
                    <p>
                        Instead, their goal is to setup the best strategy possible that would win them the highest percentage of games. Their best strategy success rate is called the value of the game.
                    </p>
                    <p>
                        Finding the value of the game is an optimization problem; to turn it into a decision problem, we instead ask whether the game's value is \(\geq\frac{2}{3}\).
                        This way, we can use our decision problem complexity classes to categorize a game. Let's see an example on the next page.
                    </p>
                </div>
                <div class="plot">
                    <h5>PROVER ⇿ PLAYER</h5>
                    <p>An all-powerful machine, like Merlin, that provides information to the verifier.</p>
                    <h5>VERIFIER ⇿ REFEREE</h5>
                    <p>Our machine, like Arthur, whose complexity we are measuring. The referee questions the players, and based on their answers, "plays," determines whether they won.</p>
                    <h5>NONLOCAL GAME VALUE</h5>
                    <p>The probability that the players can win the game given their best strategy among all possible strategies.</p>
                </div>
                <div class="plot-butt">
                </div>
                <div class="overlay hide overlay_explains">
                </div>
                <div class="overlay hide overlay_links">
                </div>       
            </section>

            <!-- SECTION 04 -->
            <!-- CHSH GAME -->
            <section class="grid" id="classMIP">
                <div class="head">
                    <h2>Class MIP: CHSH game</h2>
                </div>
                <div class="main-intro">
                    <p>
                        Our two provers-players are Alice and Bob. Before playing, they can select a strategy to follow in the game.
                        You are the verifier-referee. As the game starts, you send a random bit x to Alice and a random bit y to Bob. They respond according to their strategy.
                        Alice and Bob win the game if \(x \wedge y = a \oplus b\). In words, they win if the sum of their answers modulo 2 equals the product of the inputs.
                    </p>
                </div>
                <div class="main-act s04_main">
                    <div class="s04_a abob">
                        <h3>Alice's strategies</h3>
                        <div class="strats">
                            <div class="strat" data-s="0">
                                <p>\(x\)</p>
                                <p></p>
                                <p>\(a\)</p>
                                <p>\(0\)</p>
                                <p>\(\rightarrow\)</p>
                                <p>\(0\)</p>
                                <p>\(1\)</p>
                                <p>\(\rightarrow\)</p>
                                <p>\(0\)</p>
                            </div>
                            <div class="strat" data-s="1">
                                <p>\(x\)</p>
                                <p></p>
                                <p>\(a\)</p>
                                <p>\(0\)</p>
                                <p>\(\rightarrow\)</p>
                                <p>\(0\)</p>
                                <p>\(1\)</p>
                                <p>\(\rightarrow\)</p>
                                <p>\(1\)</p>
                            </div>
                            <div class="strat" data-s="2">
                                <p>\(x\)</p>
                                <p></p>
                                <p>\(a\)</p>
                                <p>\(0\)</p>
                                <p>\(\rightarrow\)</p>
                                <p>\(1\)</p>
                                <p>\(1\)</p>
                                <p>\(\rightarrow\)</p>
                                <p>\(0\)</p>
                            </div>
                            <div class="strat" data-s="3">
                                <p>\(x\)</p>
                                <p></p>
                                <p>\(a\)</p>
                                <p>\(0\)</p>
                                <p>\(\rightarrow\)</p>
                                <p>\(1\)</p>
                                <p>\(1\)</p>
                                <p>\(\rightarrow\)</p>
                                <p>\(1\)</p>
                            </div>
                        </div>
                    </div>
                    <div class="s04_c">
                        <h3>Referee</h3>
                        <div class="s04_table">
                            <p>\(x\)</p>
                            <p>\(y\)</p>
                            <p>\(a\)</p>
                            <p>\(b\)</p>
                            <p>\(x \wedge y\)</p>
                            <p>\(a \oplus b\)</p>
                        </div>
                    </div>
                    <div class="s04_b abob">
                        <h3>Bob's strategies</h3>
                        <div class="strats">
                            <div class="strat" data-s="0">
                                <p>\(y\)</p>
                                <p></p>
                                <p>\(b\)</p>
                                <p>\(0\)</p>
                                <p>\(\rightarrow\)</p>
                                <p>\(0\)</p>
                                <p>\(1\)</p>
                                <p>\(\rightarrow\)</p>
                                <p>\(0\)</p>
                            </div>
                            <div class="strat" data-s="1">
                                <p>\(y\)</p>
                                <p></p>
                                <p>\(b\)</p>
                                <p>\(0\)</p>
                                <p>\(\rightarrow\)</p>
                                <p>\(0\)</p>
                                <p>\(1\)</p>
                                <p>\(\rightarrow\)</p>
                                <p>\(1\)</p>
                            </div>
                            <div class="strat" data-s="2">
                                <p>\(y\)</p>
                                <p></p>
                                <p>\(b\)</p>
                                <p>\(0\)</p>
                                <p>\(\rightarrow\)</p>
                                <p>\(1\)</p>
                                <p>\(1\)</p>
                                <p>\(\rightarrow\)</p>
                                <p>\(0\)</p>
                            </div>
                            <div class="strat" data-s="3">
                                <p>\(y\)</p>
                                <p></p>
                                <p>\(b\)</p>
                                <p>\(0\)</p>
                                <p>\(\rightarrow\)</p>
                                <p>\(1\)</p>
                                <p>\(1\)</p>
                                <p>\(\rightarrow\)</p>
                                <p>\(1\)</p>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="main-butt">
                    <div class="button b-orange s04_play1">
                        <h3>PLAY ONCE</h3>
                    </div>
                    <div class="button b-orange s04_playon">
                        <h3>KEEP PLAYING</h3>
                    </div>
                </div>
                <div class="plot">
                    <div class="plot_wrap s04_plot" id="s04_plot">
                        <!-- dynamically populated -->
                    </div>
                </div>
                <div class="plot-butt">
                    <div class="button b-blue b-explains">
                        <h3 class="b-explain-04">EXPLAIN</h3>
                    </div>
                    <div class="button b-purple b-links">
                        <h3 class="b-link">LINKS</h3>
                    </div>
                </div>
                <div class="overlay hide overlay_explains">
                    <p>
                        You should see a set of simulations ran for a few select strategies appear on the chart on the right. With a large number of games played,
                        we can see statistical results as their win percentages stabilize. Some strategies lead to a very poor performance, winning just around a quarter of the games.
                    </p>
                    <p>
                        The best of the strategies shown, A4B4 is Alice and Bob completely ignoring the question and just answering \(1\) every time.
                        Its win probability is 75%, and in fact this is the highest probability of win that Bob and Alice can achieve. You are welcome to try and find other strategies with the same win percentage, but you won't be able to beat it.
                        You can even enumerate all 16 strategies (or accompany it by the "both-Alice-and-Bob-answer-randomly" strategy!), and evaluate their chances against the 4 question sets.
                    </p>
                    <p>
                        You will find out that 75% is the best Alice and Bob can do, which makes \(0.75\) the classical value of the game.
                    </p>
                    <p>
                        Obviously, the example is fairly simplistic, but it illustrates the idea of multi-prover interactive proofs.
                        In more complicated set-ups, the verifier is cross-checking both provers' answers - for example, having two merlins in the previous problem of graph non-isomorphism would allow you to draw your conclusion as soon as the two Merlins disagree!
                    </p>
                </div>
                <div class="overlay hide overlay_links">
                    <h3>Encyclopedia links</h3>
                    <div class="links">
                        <a class="link" href="https://www.wikiwand.com/en/Complexity_class" target="_blank">
                            <canvas></canvas>
                            <p>Complexity Classes</p>
                            <p class="link_src">at Wikipedia</p>
                        </a>
                        <a class="link" href="https://www.wikiwand.com/en/FP_(complexity)" target="_blank">
                            <canvas></canvas>
                            <p>Complexity of Function Problems</p>
                            <p class="link_src">at Wikipedia</p>
                        </a>
                        <a class="link" href="https://www.wikiwand.com/en/P_(complexity)" target="_blank">
                            <canvas></canvas>
                            <p>Complexity Class P</p>
                            <p class="link_src">at Wikipedia</p>
                        </a>
                        <a class="link" href="https://www.wikiwand.com/en/Computational_problem" target="_blank">
                            <canvas></canvas>
                            <p>Types of computational problems</p>
                            <p class="link_src">at Wikipedia</p>
                        </a>
                        <a class="link" href="https://complexityzoo.net/Complexity_Zoo:F#fp" target="_blank">
                            <canvas></canvas>
                            <p>Class FP: Function Polynomial-Time</p>
                            <p class="link_src">at Complexity Zoo</p>
                        </a>
                        <a class="link" href="https://complexityzoo.net/Complexity_Zoo:P#p" target="_blank">
                            <canvas></canvas>
                            <p>Class P: Polynomial-Time</p>
                            <p class="link_src">at Complexity Zoo</p>
                        </a>
                    </div>
                    <h3>Beginner Resources</h3>
                    <div class="links">
                        <a class="link" href="https://cs.stackexchange.com/questions/79707/does-every-computational-problem-have-a-decision-version" target="_blank">
                            <canvas></canvas>
                            <p>Do all problems have decision versions?</p>
                            <p class="link_src">at Stack Exchange</p>
                        </a>
                        <a class="link" href="https://cstheory.stackexchange.com/questions/37812/what-exactly-are-the-classes-fp-fnp-and-tfnp" target="_blank">
                            <canvas></canvas>
                            <p>What are the FP, FNP and TFNP classes?</p>
                            <p class="link_src">at Stack Exchange</p>
                        </a>
                        <a class="link" href="https://brilliant.org/wiki/turing-machines/?subtopic=algorithms&chapter=computability" target="_blank">
                            <canvas></canvas>
                            <p>What are Turing Machines?</p>
                            <p class="link_src">at Brilliant</p>
                        </a>
                        <a class="link" href="https://www.cs.stanford.edu/~trevisan/cs254-10/lecture02.pdf" target="_blank">
                            <canvas></canvas>
                            <p>About Computational Problems</p>
                            <p class="link_src">by Luca Trevisan</p>
                            <p class="link_src">at Stanford University</p>
                        </a>
                        <a class="link" href="http://www.cs.ecu.edu/karl/6420/spr16/Notes/P/examples.html" target="_blank">
                            <canvas></canvas>
                            <p>Examples of problems in P</p>
                            <p class="link_src">at East Carolina University</p>
                        </a>
                        <a class="link" href="https://www.youtube.com/watch?v=WaNLJf8xzC4" target="_blank">
                            <canvas></canvas>
                            <p>What's the fastest way to sort your bookshelf?</p>
                            <p class="link_src">by TED-Ed</p>
                        </a>
                        <a class="link" href="https://www.geeksforgeeks.org/time-complexities-of-all-sorting-algorithms/" target="_blank">
                            <canvas></canvas>
                            <p>Time complexities of sorting algorithms</p>
                            <p class="link_src">by Geeks for Geeks</p>
                        </a>
                    </div>
                    <h3>Advanced Study</h3>
                    <div class="links">
                        <a class="link" href="https://www.sciencedirect.com/science/article/pii/S0022000005800091" target="_blank">
                            <canvas></canvas>
                            <p>A taxonomy of complexity classes of functions</p>
                            <p class="link_src">by Alan L. Selman</p>
                            <p class="link_src">in Journal of Computer and System Sciences</p>
                        </a>
                        <a class="link" href="https://klein.mit.edu/~sipser/book.html" target="_blank">
                            <canvas></canvas>
                            <p>Introduction to the Theory of Computation (3rd ed.)</p>
                            <p class="link_src">by Michael Sipser</p>
                        </a>
                        <a class="link" href="https://www.cs.utexas.edu/~ear/cs341/automatabook/AutomataTheoryBook.pdf" target="_blank">
                            <canvas></canvas>
                            <p>Automata, Computability and Complexity</p>
                            <p class="link_src">by Elaine Rich</p>
                        </a>
                    </div>
                </div>       
            </section>

            <!-- SECTION 04.5 -->
            <!-- QUANTUM ENTANGLEMENT -->
            <section class="grid" id="quantumentanglement">
                <div class="head">
                    <h2>Quantum Entanglement</h2>
                </div>
                <div class="main-full">
                    <p>
                        We're finally arriving at the crux of the exploration. We now have two provers whose answers need to be coordinated, but who aren't allowed to communicate.
                        One way they can achieve this correlation is via quantum entaglement. There's limited space to explain here, so let's layout the basics and feel free to consult the linked resources for further explanations!
                    </p>
                    <p>
                        Until now, we've worked in the classical world, where bits are either \(0\) or \(1\). A qubit, on the other hand, can be in a superposition of \(\ket{0}\) and \(\ket{1}\), with a certain probability of us observing either of the two when we measure it.
                        For example, a qubit could be in the state \(\psi = \frac{\ket{0}}{\sqrt{2}} + \frac{\ket{1}}{\sqrt{2}}\). When measured, it has a 50% chance of showing up as \(\ket{0}\), calculated as \( |\braket{0\vert\psi}|^2 = | \begin{bmatrix}1 & 0\end{bmatrix}\begin{bmatrix}\frac{1}{\sqrt{2}} \\ \frac{1}{\sqrt{2}}\end{bmatrix} |^2 = 0.5\),
                        where we use matrix notation with the basis \(\begin{bmatrix} \ket{0} \\ \ket{1} \end{bmatrix}\).
                    </p>
                    <p>
                        If we have two qubits, we can describe their state at once with a tensor product, e.g. \(\ket{\psi}_A \otimes \ket{\phi}_B\). For example, if \(\ket{\psi} = \frac{\ket{0} + \ket{1}}{\sqrt{2}}\) and \(\ket{\phi} = \ket{0}\), 
                        then \(\ket{\psi} \otimes \ket{\phi} = \frac{\ket{00}}{\sqrt{2}} + 0\times \ket{01} + \frac{\ket{10}}{\sqrt{2}} + 0\times \ket{11}\).
                    </p>
                    <p>
                        However, some states cannot be split into a tensor product. Take for example \(\ket{\psi} = \frac{\ket{00} + \ket{11}}{\sqrt{2}}\) - no matter how hard you try, you won't find a tensor product to generate it. This is called an entangled state. If we calculate the measurement probabilities, we find out that there is a 50% chance of measuring \(\ket{00}\)
                        and 50% chance of measuring \(\ket{11}\). If we give the two qubits to Alice and Bob while entangled, and Alice measures a \(\ket{0}\) state on her qubit, Bob's MUST be also \(\ket{0}\), because the probability of a \(\ket{01}\) state is 0%!
                    </p>
                </div>
                <div class="plot">
                    <h5>BIT</h5>
                    <p>A unit of classical information, can be either \(0\) or \(1\).</p>
                    <h5>QUBIT</h5>
                    <p>A unit of quantum information, can be in some superposition of \(\ket{0}\) and \(\ket{1}\)</p>
                    <h5>2-QUBIT STATE</h5>
                    <p>A system of two qubits: \(\ket{\psi} = c_1\ket{00} + c_2\ket{01} + c_3\ket{10} + c_4\ket{11}\)</p>
                    <h5>ENTANGLED STATE</h5>
                    <p>A 2-qubit state that cannot be factored into a tensor product, like \(\ket{\psi} = \frac{\ket{00} + \ket{11}}{\sqrt{2}}\)</p>
                </div>
                <div class="plot-butt">
                </div>
                <div class="overlay hide overlay_explains">
                </div>
                <div class="overlay hide overlay_links">
                </div>       
            </section>

            <!-- SECTION 05 -->
            <!-- QUANTUM STRATEGY -->
            <section class="grid" id="classMIPstar">
                <div class="head">
                    <h2>Class MIP*: CHSH game again</h2>
                </div>
                <div class="main-intro">
                    <p>
                        This time, Alice and Bob have prepared a special strategy for the same game: beforehand, they entangled a qubit pair \(\ket{\psi} = \frac{\ket{00} + \ket{11}}{\sqrt{2}}\) and each of them took one of the qubits.
                        They also prepared their measurement axis in a specific way, which allows them to win as often as possible - play and watch how they do!
                    </p>
                </div>
                <div class="main-act s05_main">
                    <div class="s05_a s05_abob">
                        <h3>Alice's qubit</h3>
                        <div class="gate agate">
                            <div class="sq sq0">\(\ket{0_0}\)</div>
                            <div class="sq sq1">\(\ket{1_1}\)</div>
                            <div class="sq sqPLUS">\(\ket{+_0}\)</div>
                            <div class="sq sqMINUS">\(\ket{-_1}\)</div>
                        </div>
                        <p>
                            If I receive \(x=0\), I'll measure along the \(\ket{0}, \ket{1}\) axis,
                            otherwise along the \(\ket{+}, \ket{-}\) axis.
                        </p>
                    </div>
                    <div class="s04_c">
                        <h3>Referee</h3>
                        <div class="s05_table">
                            <p>\(a\)</p>
                            <p>\(b\)</p>
                            <p>\(x \wedge y\)</p>
                            <p>\(a \oplus b\)</p>
                        </div>
                    </div>
                    <div class="s05_b s05_abob">
                        <h3>Bob's qubit</h3>
                        <div class="gate bgate">
                            <div class="sq sqA">\(\ket{A_0}\)</div>
                            <div class="sq sqB">\(\ket{B_1}\)</div>
                            <div class="sq sqa">\(\ket{a_0}\)</div>
                            <div class="sq sqb">\(\ket{b_1}\)</div>
                        </div>
                        <p>
                            If I receive \(x=0\), I'll measure along the \(\ket{A}, \ket{B}\) axis,
                            otherwise along the \(\ket{a}, \ket{b}\) axis.
                        </p>
                    </div>
                </div>
                <div class="main-butt">
                    <div class="button b-orange s05_play1">
                        <h3>PLAY ONCE</h3>
                    </div>
                    <div class="button b-orange s05_playon">
                        <h3>KEEP PLAYING</h3>
                    </div>
                </div>
                <div class="plot">
                    <div class="plot_wrap s05_plot" id="s05_plot">
                        <!-- dynamically populated -->
                    </div>
                </div>
                <div class="plot-butt">
                    <div class="button b-blue b-explains">
                        <h3 class="b-explain-05">EXPLAIN</h3>
                    </div>
                    <div class="button b-purple b-links">
                        <h3 class="b-link">LINKS</h3>
                    </div>
                </div>
                <div class="overlay hide overlay_explains">
                    <p>
                        Compare the quantum strategy to some of the classical strategies Alice and Bob employed previously. They are doing much better now! With a single quantum-entangled qubit and some smart measuring axis, they upped the value of the game to 85%.
                    </p>
                    <p>
                        Let's translate the nonlocal games language back into a complexity class now.
                        We say that a language belongs to the complexity class MIP* if you can translate it into a nonlocal game G, with quantum value over 2/3 for all strings belonging to the language and below 1/3 for all strings not belonging to the language.
                    </p>
                    <p>
                        We know that MIP* contains MIP, because you can always choose the "quantum" strategy of ignoring your qubits and going with the best classical strategy. 
                        We have also seen an example of a quantum strategy doing better than a classical strategy, suggesting that there are problems for which a quantum strategy is enough where a classical one cannot do.
                        (In reality both of these statements come with more details, also including the lower bound).
                    </p>
                    <p>
                        Determining whether a string belongs to a langauge is then a question of finding the quantum value of game G, which is done by approximation, hopefully to a convergent value.
                    </p>
                    <p>
                        Continue to the last page to see the relationship between MIP* and RE!
                    </p>
                </div>
                <div class="overlay hide overlay_links">
                    <h3>Encyclopedia links</h3>
                    <div class="links">
                        <a class="link" href="https://www.wikiwand.com/en/Complexity_class" target="_blank">
                            <canvas></canvas>
                            <p>Complexity Classes</p>
                            <p class="link_src">Wikipedia</p>
                        </a>
                        <a class="link" href="https://www.wikiwand.com/en/FP_(complexity)" target="_blank">
                            <canvas></canvas>
                            <p>Complexity of Function Problems</p>
                            <p class="link_src">Wikipedia</p>
                        </a>
                        <a class="link" href="https://www.wikiwand.com/en/P_(complexity)" target="_blank">
                            <canvas></canvas>
                            <p>Complexity Class P</p>
                            <p class="link_src">Wikipedia</p>
                        </a>
                        <a class="link" href="https://www.wikiwand.com/en/Computational_problem" target="_blank">
                            <canvas></canvas>
                            <p>Types of computational problems</p>
                            <p class="link_src">Wikipedia</p>
                        </a>
                        <a class="link" href="https://complexityzoo.net/Complexity_Zoo:F#fp" target="_blank">
                            <canvas></canvas>
                            <p>Class FP: Function Polynomial-Time</p>
                            <p class="link_src">Complexity Zoo</p>
                        </a>
                        <a class="link" href="https://complexityzoo.net/Complexity_Zoo:P#p" target="_blank">
                            <canvas></canvas>
                            <p>Class P: Polynomial-Time</p>
                            <p class="link_src">Complexity Zoo</p>
                        </a>
                    </div>
                    <h3>Beginner Resources</h3>
                    <div class="links">
                        <a class="link" href="https://cs.stackexchange.com/questions/79707/does-every-computational-problem-have-a-decision-version" target="_blank">
                            <canvas></canvas>
                            <p>Do all problems have decision versions?</p>
                            <p class="link_src">Stack Exchange</p>
                        </a>
                        <a class="link" href="https://cstheory.stackexchange.com/questions/37812/what-exactly-are-the-classes-fp-fnp-and-tfnp" target="_blank">
                            <canvas></canvas>
                            <p>What are the FP, FNP and TFNP classes?</p>
                            <p class="link_src">Stack Exchange</p>
                        </a>
                        <a class="link" href="https://brilliant.org/wiki/turing-machines/?subtopic=algorithms&chapter=computability" target="_blank">
                            <canvas></canvas>
                            <p>What are Turing Machines?</p>
                            <p class="link_src">Brilliant</p>
                        </a>
                        <a class="link" href="https://www.cs.stanford.edu/~trevisan/cs254-10/lecture02.pdf" target="_blank">
                            <canvas></canvas>
                            <p>About Computational Problems</p>
                            <p class="link_src">Luca Trevisan</p>
                        </a>
                        <a class="link" href="http://www.cs.ecu.edu/karl/6420/spr16/Notes/P/examples.html" target="_blank">
                            <canvas></canvas>
                            <p>Examples of problems in P</p>
                            <p class="link_src">East Carolina University</p>
                        </a>
                        <a class="link" href="https://www.youtube.com/watch?v=WaNLJf8xzC4" target="_blank">
                            <canvas></canvas>
                            <p>What's the fastest way to sort your bookshelf?</p>
                            <p class="link_src">TED-Ed</p>
                        </a>
                        <a class="link" href="https://www.geeksforgeeks.org/time-complexities-of-all-sorting-algorithms/" target="_blank">
                            <canvas></canvas>
                            <p>Time complexities of sorting algorithms</p>
                            <p class="link_src">Geeks for Geeks</p>
                        </a>
                    </div>
                    <h3>Advanced Study</h3>
                    <div class="links">
                        <a class="link" href="https://www.sciencedirect.com/science/article/pii/S0022000005800091" target="_blank">
                            <canvas></canvas>
                            <p>A taxonomy of complexity classes of functions</p>
                            <p class="link_src">Alan L. Selman</p>
                        </a>
                        <a class="link" href="https://klein.mit.edu/~sipser/book.html" target="_blank">
                            <canvas></canvas>
                            <p>Introduction to the Theory of Computation (3rd ed.)</p>
                            <p class="link_src">Michael Sipser</p>
                        </a>
                        <a class="link" href="https://www.cs.utexas.edu/~ear/cs341/automatabook/AutomataTheoryBook.pdf" target="_blank">
                            <canvas></canvas>
                            <p>Automata, Computability and Complexity</p>
                            <p class="link_src">Elaine Rich</p>
                        </a>
                    </div>
                </div>       
            </section>

            <!-- SECTION 05.5 -->
            <!-- MIP* = RE -->
            <section class="grid" id="mipstarisre">
                <div class="head">
                    <h2>MIP* = RE</h2>
                </div>
                <div class="main-full">
                    <p>
                        The previous exercises established the MIP* class, but it's also important to talk about the RE class.
                        RE stands for recursively enumerable, the class of languages whose 'yes' instances a Turing machine can list one by one.
                        In a less cryptic way, it can also be defined as language to which a Turing machine can verify the 'yes' problems, but might run indefinitely for 'no' problems.
                    </p>
                    <p>
                        A famous example of a language belonging to RE is the Halting Problem, asking whether a given program will stop running; 
                        you can run it, and say 'yes' if it stops, but it might just keep running forever if the true answer is no.
                        Because of an ensuing paradox, it is undecidable whether a program will halt, and a reduction to this problem is often used to show other problems are undecidable.
                        A reduction is a statement of the type "if you could solve this problem, you could also solve the halting problem, and that's impossible."
                    </p>
                    <p>
                        This is exactly the type of structure Ji et al. used to show that it's also undecidable whether a string belongs to MIP*.
                        Their idea translates the question of whether a program halts into a quantum nonlocal game - if the game has quantum value 1, the machine halts, and if it has value less than 1/2, it doesn't halt.
                    </p>
                    <p>
                        If there was a way to calculate (or at least approximate) the quantum value of a game, to figure out if a string belongs to MIP*,
                        Ji et al.'s procedure would allow us to use this algorithm and figure out the Halting problem - which is impossible!
                        So there cannot be a solver for MIP*, which must thus be undecidable and equal to RE.
                    </p>
                </div>
                <div class="plot">
                    <h5>Class P</h5>
                    <p>Solvable by a Turing machine in polynomial time</p>
                    <h5>Class BPP</h5>
                    <p>Solvable with an error bound by a Turing machine in polynomial time</p>
                    <h5>Class IP</h5>
                    <p>Verifiable with an error bound by a Turing machine in an interactive proof protocol</p>
                    <h5>Class MIP*</h5>
                    <p>Verifiable with an error bound by a Turing machine against multiple provers sharing quantum entanglement</p>
                </div>
                <div class="plot-butt">
                </div>
                <div class="overlay hide overlay_explains">
                </div>
                <div class="overlay hide overlay_links">
                </div>       
            </section>

        </div>


        <!-- Scripts -->
        <!-- Sortable utility by RubaXa & owenm -->
        <script src="https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js"></script>
        <!-- Graphing library by Cytoscape.js -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/cytoscape/3.20.0/cytoscape.min.js"></script>
        <!-- confetti by Kiril Vatev @catdad -->
        <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.5.1/dist/confetti.browser.min.js"></script>        <script src="assets/js/jquery.min.js"></script>
        <script src="assets/js/jcanvas.min.js"></script>
        <script src="assets/js/jquery.canvaswrapper.js"></script>
        <script src="assets/js/jquery.colorhelpers.js"></script>
        <script src="assets/js/browser.min.js"></script>
        <!-- Charting library by Flot.js -->
        <script src="assets/js/jquery.flot.js"></script>
        <script src="assets/js/jquery.flot.legend.js"></script>
        <script src="assets/js/jquery.flot.axislabels.js"></script>
        <script src="assets/js/jquery.flot.resize.js"></script>
        <script src="assets/js/main.js"></script>
    </body>
</html>